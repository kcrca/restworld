import datetime
import os
from pathlib import Path
from typing import Iterable

from restworld.commands import good_name, Command, Range, MOD, User


def lines(*orig: any) -> Iterable[any]:
    """Flatten a list of (command) strings into a one-line-per-command flat list."""
    for item in orig:
        if isinstance(item, Command):
            yield item
        elif isinstance(item, str):
            if item.find('\n') >= 0:
                yield from lines(*item.split('\n'))
            else:
                yield item
        elif isinstance(item, Iterable):
            yield from lines(*item)
        elif item is not None:
            yield str(item)


class Loop:
    class Debug:
        def _set_prefix_override(self, func):
            Loop._prefix_override = func

        def _set_setup_override(self, func):
            Loop._setup_override = func

    _prefix_override = None
    _setup_override = None

    def __init__(self, name: str, objective: str, items):
        self.name = good_name(name)
        self.user = User(name)
        self.objective = good_name(objective)
        self.max_objective = objective + '_max'
        self.items = items
        self.before_cmds = []
        self.after_cmds = []

    @classmethod
    def debug(cls):
        return Loop.Debug()


    def before(self, *commands):
        self.before_cmds.append(commands)
        return self

    def after(self, *commands):
        self.after_cmds.append(commands)
        return self

    def run(self, body_func):
        result = list(lines(self._setup_for()))
        result.append(lines(self.before_cmds))
        for (i, item) in enumerate(self.items):
            once = body_func(self.name, i, item)
            prefix = self._prefix_for(i)
            for line in lines(once):
                result.append(str(prefix) + line)
        result.append(lines(self.after_cmds))
        return lines(result)

    def _setup_for(self):
        if Loop._setup_override:
            return Loop._setup_override()
        return (
            Command().scoreboard().players().set(self.user, self.objective, len(self.items)),
            Command().execute().unless().score(self.name, self.objective).matches(
                Range(0, len(self.items) - 1)).run().scoreboard().players().operation(self.user, self.objective, MOD,
                                                                                      self.user, self.max_objective)
        )

    def _prefix_for(self, i):
        if Loop._prefix_override:
            return Loop._prefix_override(i)
        return Command().execute().if_().score(self.name, self.objective).matches(i).run()


class Function:
    def __init__(self, name: Path, *commands: any):
        self.name = name
        self.commands = []
        self.add(*commands)

    def __str__(self):
        return self._warning() + '\n'.join(self.commands)

    def add(self, *commands: any):
        self.commands += (str(x) for x in commands)

    def _warning(self):
        return '# Generated by %s @ %s\n' % (os.getlogin(), datetime.datetime.now())


class Library:
    def __init__(self, path: Path, pack: str):
        self.top = path / pack / 'data' / pack / 'functions'
        self._functions = []

    def add(self, *functions: Function):
        self._functions.append(*functions)

    def save(self, *functions: Function):
        for f in functions:
            path = self.top / f.name.with_suffix('.mcfunction')
            parent = path.parent
            parent.mkdir(parents=True, exist_ok=True)
            with open(path) as f:
                f.write(str(f))
