import datetime
import os
from pathlib import Path
from typing import Iterable

from restworld.commands import good_name


def lines(*orig: any) -> Iterable[any]:
    """Flatten a list of (command) strings into a one-line-per-command flat list."""
    for item in orig:
        if isinstance(item, str):
            if item.find('\n') >= 0:
                yield from lines(*item.split('\n'))
            else:
                yield item
        elif isinstance(item, Iterable):
            yield from lines(*item)
        else:
            yield item


class Loop:
    def __init__(self, name: str, items, body):
        self.name = good_name(name)
        self.items = items
        self.body = body
        self.before = []
        self.after = []

    def before(self, *commands: any):
        self.before.append(str(x) for x in commands)

    def after(self, *commands: any):
        self.after.append(str(x) for x in commands)

    def run(self):
        for c in self._setup():
            yield c
        for c in self.before:
            yield c
        self._run_loop()
        for c in self.after:
            yield c

    def _setup(self):
        return ()

    def _run_loop(self):
        pass


class Function:
    def __init__(self, name: Path, *commands: any):
        self.name = name
        self.commands = []
        self.add(*commands)

    def __str__(self):
        return self._warning() + '\n'.join(self.commands)

    def add(self, *commands: any):
        self.commands += (str(x) for x in commands)

    def _warning(self):
        return '# Generated by %s @ %s\n' % (os.getlogin(), datetime.datetime.now())


class Library:
    def __init__(self, path: Path, pack: str):
        self.top = path / pack / 'data' / pack / 'functions'
        self._functions = []

    def add(self, *functions: Function):
        self._functions.append(*functions)

    def save(self, *functions: Function):
        for f in functions:
            path = self.top / f.name.with_suffix('.mcfunction')
            parent = path.parent
            parent.mkdir(parents=True, exist_ok=True)
            with open(path) as f:
                f.write(str(f))
