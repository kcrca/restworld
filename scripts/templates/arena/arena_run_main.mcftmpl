<%namespace name="base" file="../base.mcftmpl"/>
<%namespace file="../sign_base.mcftmpl" import="*"/>

## This is NOT intended to be run on the clock. It is only called "_main" because that gives us a
## "_cur" function, which is useful when paging through the signs. Do not create the _home armor stand.

<%def name="arena_sign(y, z, hunter, victim, hunter_nbt=None, victim_nbt=None, when=None, i=None)">
<%
nbts = {
    'Drowned': 'HandItems:[{id:trident,Count:1}]',
    'Goat': 'IsScreamingGoat:True',
    'Hoglin': 'IsImmuneToZombification:True',
    'Panda': 'MainGene:aggressive',
    'Phantom': 'AX:1000,AY:110,AZ:-1000',
    'Piglin Brute': 'HandItems:[{id:golden_axe,Count:1}],IsImmuneToZombification:True',
    'Piglin': 'IsImmuneToZombification:True,HandItems:[{id:golden_sword,Count:1},{}]',
    'Pillager': 'HandItems:[{id:crossbow,Count:1},{}]',
    'Skeleton': 'HandItems:[{id:bow,Count:1}],ArmorItems:[{id:iron_boots,Count:1,tag:{RepairCost:1,Enchantments:[{lvl:9,id:protection}]}},{},{},{}]',
    'Slime': 'Size:0',
    'Magma Cube': 'Size:0',
    'Stray': 'HandItems:[{id:bow,Count:1}],ArmorItems:[{id:iron_boots,Count:1,tag:{RepairCost:1,Enchantments:[{lvl:9,id:protection}]}},{},{},{}]',
    'Vindicator': 'Johnny:True,HandItems:[{id:iron_axe,Count:1},{}]',
    'Wither Skeleton': 'HandItems:[{id:stone_sword,Count:1},{}]',
    'Zombified Piglin': 'HandItems:[{id:golden_sword,Count:1}]',
}

wet = False
if hunter[-2:] == ':w':
    wet = True
    hunter = hunter[:-2]

def incr_cmd(which, mob):
    my_nbts = ['Tags:[battler,%s]' % which]
    added_nbt = nbts.get(mob, None)
    if added_nbt:
	my_nbts.append(added_nbt)
    if which == 'hunter':
	my_nbts.append('Rotation:[180f,0f]')
    incr = 'summon %s ~0 ~2 ~0 {%s}' % (Thing(mob).id, ','.join(my_nbts))
    incr_cmd = 'execute if score %s_count funcs < arena_count funcs at @e[tag=%s_spawn,sort=random,limit=1] run %s' % (which, which, incr)
    return incr_cmd

vs = 'vs.'
%>
${when(i)} setblock ~-2 ~${y} ~${z} air
${when(i)} setblock ~-2 ~${y} ~${z} oak_wall_sign[facing=east]{\
    ${sign_nbt(0, 'execute at @e[tag=monitor_home] run fill ~-12 ~4 ~-12 ~12 ~2 ~12 %s' % ('water' if wet else 'air'), '', name='controls')},\
    ${sign_nbt(1, 'execute at @e[tag=monitor_home] run data merge block ~2 ~0 ~0 {Command:"%s"}' % incr_cmd('hunter', hunter), hunter, name='controls')},\
    ${sign_nbt(2, 'execute at @e[tag=monitor_home] run data merge block ~3 ~0 ~0 {Command:"%s"}' % incr_cmd('victim', victim), vs, name='controls')},\
    ${sign_nbt(3, 'function restworld:arena/start_battle', victim, name='controls')}\
}
</%def>
<%
import sys

num_rows = 2
stride_length = 6
row_length = stride_length / num_rows
if stride_length % num_rows != 0:
    sys.stderr.write('Stride length(%d) is not a multiple of the number of rows (%d)' % (stride_length, num_rows))
    sys.exit(1)
if row_length % 2 == 0:
    # Needed so we can center on the middle sign
    sys.stderr.write("Row length(%d) is not odd" % row_length)
    sys.exit(1)

battles = [
    ('Vindicator', 'Iron Golem'),
    ('Pillager', 'Snow Golem'),
    ('Illusioner', 'Snow Golem'),
    ('Evoker', 'Iron Golem'),
    ('Vex', 'Snow Golem'),
    ('Drowned', 'Snow Golem'),

    ('Wither Skeleton', 'Piglin'),
    ('Skeleton', 'Iron Golem'),
    ('Shulker', 'Snow Golem'),
    ('Stray', 'Iron Golem'),
    ('Wither', 'Pillager'),
    ('Blaze', 'Snow Golem'),

    ('Piglin Brute', 'Vindicator'),
    ('Witch', 'Snow Golem'),
    ('Wolf', 'Sheep'),
    ('Goat', 'Sheep'),
    ('Fox', 'Chicken'),
    ('Frog', 'Magma Cube'),

    ('Cat', 'Rabbit'),
    ('Ravager', 'Iron Golem'),
    ('Polar Bear', 'Vindicator'),
    ('Hoglin', 'Vindicator'),
    ('Zoglin', 'Vindicator'),
    ('Zombified Piglin', 'Vindicator'),

    ('Panda', 'Vindicator'),
    ('Spider', 'Snow Golem'),
    ('Cave Spider', 'Snow Golem'),
    ('Phantom', 'Rabbit'),
    ('Parrot', 'Vindicator'),
    ('Axolotl:w', 'Drowned'),
]

## Some set aisde for adding if we need them
##  ('Axolotl', 'Guardian'),
##  ('Ocelot', 'Chicken'),
##  ('Axolotl', 'Elder Guardian'),
## These don't work unelss we figure out how to kill the ones that spawn when a larger is killed
##  ('Slime', 'Iron Golem'),
##  ('Magma Cube', 'Iron Golem'),

if len(battles) % stride_length != 0:
    sys.stderr.write('Row length (%d) is not a multiple of battle count (%d)\n' % (stride_length, len(battles)))
    sys.exit(1)

battles.sort()

chunks = []
for i in range(0, len(battles), stride_length):
    chunks.append(battles[i:i + stride_length])

num_pages = int(len(battles) / stride_length)
end = int(row_length / 2)
min_z = -end
max_z = +end
x = -2
%>

fill ~${x} ~2 ~${min_z - 1} ~${x} ~${2 + num_rows - 1} ~${max_z + 1} air

<%base:loop collection="${chunks}" args="when,i,thing">\
%for which_dir in (-1, 1):
<%
    to = (i + which_dir + num_pages) % num_pages
    text, z = ('<--', max_z + 1) if which_dir == -1 else ('-->', min_z - 1)
%>\
${when(i)} setblock ~${x} ~2 ~${z} oak_wall_sign[facing=east]{GlowingText:True,\
${sign_nbt(1, 'scoreboard players set %s funcs %d' % (var, to), text)},\
${sign_nbt(2, 'execute at @e[tag=controls_home] run function restworld:%s/%s_cur' % (room, var), '')}}
%endfor\

%for s in range(0, stride_length):
<%
    args = thing[s] + (None,) * (4 - len(thing[s]))
    y = 3 - int(s / row_length)
%>\
${arena_sign(y, max_z - (s % row_length), args[0], args[1], hunter_nbt=args[2], victim_nbt=args[3], when=when, i=i)}
%endfor
</%base:loop>
